

import base64
from io import BytesIO
import os
import time
from typing import Union
import wave

import PIL
from loguru import logger
import numpy as np

from src.engine_utils.directory_info import DirectoryInfo


class AudioUtils:

    @staticmethod
    def read_wav_to_bytes(file_path) -> tuple[bytes, int]:
        try:
            # æ‰“å¼€WAVæ–‡ä»¶
            with wave.open(file_path, 'rb') as wav_file:
                # è·å–WAVæ–‡ä»¶çš„å‚æ•°
                params = wav_file.getparams()
                logger.info("Channels: {}, Sample Width: {}, Frame Rate: {}, Number of Frames: {}",
                            params.nchannels, params.sampwidth, params.framerate, params.nframes)

                # è¯»å–æ‰€æœ‰å¸§
                frames = wav_file.readframes(params.nframes)
                return frames, params.framerate
        except wave.Error as e:
            logger.info("Error reading WAV file: {}", e)
            return None, None

    @classmethod
    def get_test_audio(cls) -> tuple[bytes, int]:
        audio_path = os.path.join(
            DirectoryInfo.get_project_dir(), "resource", "audio", "ymr_48k.wav"
        )
        return cls.read_wav_to_bytes(audio_path)


class VideoUtils:
    pass


class ImageUtils:
    
    @staticmethod
    def format_image(image: Union[str, np.ndarray]):
        if isinstance(image, np.ndarray):
            return ImageUtils.numpy2base64(image)
        return image
    
    # æ³¨æ„rgbé¡ºåº
    @staticmethod
    def numpy2base64(video_frame, format="JPEG"):
        # if video_frame.dtype != np.uint8:
        #     video_frame = (video_frame * 255).astype(np.uint8)

        # ğŸ¯ æ™ºèƒ½å›¾åƒä¼˜åŒ–ï¼šè‡ªåŠ¨é€‚é…AIæ¨¡å‹çš„æœ€ä½³å¤„ç†å°ºå¯¸
        optimized_frame = ImageUtils._optimize_for_ai_analysis(video_frame)

        # å°† NumPy æ•°ç»„è½¬æ¢ä¸º PIL å›¾åƒå¯¹è±¡
        image = PIL.Image.fromarray(np.squeeze(optimized_frame)[..., ::-1])

        # åˆ›å»ºä¸€ä¸ªå†…å­˜ç¼“å†²åŒº
        buffered = BytesIO()

        # å°†å›¾åƒä¿å­˜åˆ°å†…å­˜ç¼“å†²åŒºä¸­
        image.save(buffered, format=format)

        # è·å–äºŒè¿›åˆ¶æ•°æ®å¹¶ç¼–ç ä¸º Base64
        base64_image = base64.b64encode(buffered.getvalue()).decode("utf-8")

        # æ·»åŠ  Base64 æ•°æ®å¤´ï¼ˆå¯é€‰ï¼‰
        data_url = f"data:image/{format.lower()};base64,{base64_image}"
        dump_image = False
        if dump_image:
            from engine_utils.directory_info import DirectoryInfo
            ImageUtils.save_base64_image(base64_image, f"{DirectoryInfo.get_project_dir()}/temp/{time.localtime().tm_min}_{time.localtime().tm_sec}.jpg")
        return data_url
    
    @staticmethod
    def _optimize_for_ai_analysis(video_frame):
        """
        æ™ºèƒ½ä¼˜åŒ–è§†é¢‘å¸§ä»¥æé«˜AIåˆ†ææ•ˆæœ
        
        ç­–ç•¥ï¼š
        1. è‡ªåŠ¨æ£€æµ‹å›¾åƒæ¥æºï¼ˆæ‘„åƒå¤´vså±å¹•å…±äº«ï¼‰
        2. æ ¹æ®æ¥æºåº”ç”¨ä¸åŒçš„ä¼˜åŒ–ç­–ç•¥
        3. ç¡®ä¿AIæ¨¡å‹èƒ½å¤Ÿæ­£ç¡®è¯†åˆ«å†…å®¹
        """
        import cv2
        
        # è·å–åŸå§‹å°ºå¯¸
        height, width = video_frame.shape[:2]
        
        logger.info(f"ğŸ–¼ï¸ AIå›¾åƒä¼˜åŒ– - åŸå§‹å°ºå¯¸: {width}x{height}")
        
        # æ£€æµ‹å›¾åƒæ¥æºç±»å‹
        is_screen_share = ImageUtils._detect_screen_share_content(video_frame, width, height)
        
        if is_screen_share:
            # å±å¹•å…±äº«å†…å®¹çš„ä¼˜åŒ–ç­–ç•¥
            logger.info("ğŸ“º æ£€æµ‹åˆ°å±å¹•å…±äº«å†…å®¹ï¼Œåº”ç”¨å±å¹•ä¼˜åŒ–ç­–ç•¥")
            optimized = ImageUtils._optimize_screen_content(video_frame)
        else:
            # æ‘„åƒå¤´å†…å®¹çš„ä¼˜åŒ–ç­–ç•¥  
            logger.info("ğŸ“· æ£€æµ‹åˆ°æ‘„åƒå¤´å†…å®¹ï¼Œåº”ç”¨äººåƒä¼˜åŒ–ç­–ç•¥")
            optimized = ImageUtils._optimize_camera_content(video_frame)
            
        opt_height, opt_width = optimized.shape[:2]
        logger.info(f"âœ¨ AIå›¾åƒä¼˜åŒ–å®Œæˆ - ä¼˜åŒ–åå°ºå¯¸: {opt_width}x{opt_height}")
        
        return optimized
    
    @staticmethod
    def _detect_screen_share_content(frame, width, height):
        """
        æ£€æµ‹æ˜¯å¦ä¸ºå±å¹•å…±äº«å†…å®¹
        
        å¯å‘å¼åˆ¤æ–­ï¼š
        1. å°ºå¯¸æ¯”ä¾‹ï¼ˆå±å¹•å…±äº«é€šå¸¸æ˜¯å®½å±æ¯”ä¾‹ï¼‰
        2. è¾¹ç¼˜å¯†åº¦ï¼ˆå±å¹•å†…å®¹é€šå¸¸æœ‰æ›´å¤šé”åˆ©è¾¹ç¼˜ï¼‰
        3. é¢œè‰²åˆ†å¸ƒï¼ˆå±å¹•å†…å®¹é€šå¸¸æœ‰ç‰¹å®šçš„é¢œè‰²æ¨¡å¼ï¼‰
        """
        # 1. å°ºå¯¸æ¯”ä¾‹æ£€æµ‹
        aspect_ratio = width / height
        is_widescreen = aspect_ratio > 1.5  # å®½å±æ¯”ä¾‹æš—ç¤ºå±å¹•å…±äº«
        
        # 2. è¾¹ç¼˜å¯†åº¦æ£€æµ‹ï¼ˆå±å¹•å†…å®¹é€šå¸¸æœ‰æ›´å¤šæ–‡å­—å’ŒUIå…ƒç´ ï¼‰
        import cv2
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        edges = cv2.Canny(gray, 50, 150)
        edge_density = np.sum(edges > 0) / (width * height)
        is_high_edge_density = edge_density > 0.05  # é«˜è¾¹ç¼˜å¯†åº¦æš—ç¤ºå±å¹•å†…å®¹
        
        # 3. äº®åº¦åˆ†å¸ƒæ£€æµ‹ï¼ˆå±å¹•å†…å®¹é€šå¸¸äº®åº¦æ›´å‡åŒ€ï¼‰
        brightness_std = np.std(gray)
        is_uniform_brightness = brightness_std > 30  # é€‚ä¸­çš„äº®åº¦å˜åŒ–
        
        # ç»¼åˆåˆ¤æ–­
        screen_indicators = sum([is_widescreen, is_high_edge_density, is_uniform_brightness])
        is_screen_content = screen_indicators >= 2  # è‡³å°‘2ä¸ªæŒ‡æ ‡æ”¯æŒ
        
        logger.debug(f"ğŸ” å±å¹•å†…å®¹æ£€æµ‹ - å®½å±:{is_widescreen}, è¾¹ç¼˜:{is_high_edge_density}, äº®åº¦:{is_uniform_brightness} -> {is_screen_content}")
        
        return is_screen_content
    
    @staticmethod  
    def _optimize_screen_content(frame):
        """
        å±å¹•å…±äº«å†…å®¹ä¼˜åŒ–ç­–ç•¥
        
        ç›®æ ‡ï¼šä¿æŒæ–‡å­—æ¸…æ™°åº¦ï¼Œé€‚åº¦ç¼©æ”¾ä»¥é€‚åº”AIå¤„ç†
        """
        import cv2
        
        height, width = frame.shape[:2]
        
        # æ™ºèƒ½ç¼©æ”¾ç­–ç•¥ï¼šä¿æŒæ–‡å­—å¯è¯»æ€§
        # ç›®æ ‡ï¼šè®©AIæ—¢èƒ½çœ‹åˆ°å…¨å±€å¸ƒå±€ï¼Œåˆèƒ½è¯†åˆ«æ–‡å­—å†…å®¹
        if width > 1200:
            # å¤§å±å¹•å†…å®¹ï¼Œç¼©æ”¾åˆ°åˆç†å°ºå¯¸ä½†ä¿æŒå¯è¯»æ€§
            scale_factor = 800 / width  # ç¼©æ”¾åˆ°800pxå®½åº¦
            new_width = int(width * scale_factor)
            new_height = int(height * scale_factor)
            
            # ä½¿ç”¨LANCZOSæ’å€¼ä¿æŒæ–‡å­—æ¸…æ™°åº¦
            optimized = cv2.resize(frame, (new_width, new_height), interpolation=cv2.INTER_LANCZOS4)
            logger.info(f"ğŸ“º å±å¹•å†…å®¹ç¼©æ”¾: {width}x{height} -> {new_width}x{new_height}")
        else:
            # å°ºå¯¸å·²ç»åˆé€‚ï¼Œç›´æ¥ä½¿ç”¨
            optimized = frame.copy()
            logger.info("ğŸ“º å±å¹•å†…å®¹å°ºå¯¸åˆé€‚ï¼Œæ— éœ€ç¼©æ”¾")
        
        # å¯é€‰ï¼šå¢å¼ºå¯¹æ¯”åº¦ä»¥æ”¹å–„æ–‡å­—è¯†åˆ«
        # optimized = cv2.convertScaleAbs(optimized, alpha=1.1, beta=10)
        
        return optimized
    
    @staticmethod
    def _optimize_camera_content(frame):
        """
        æ‘„åƒå¤´å†…å®¹ä¼˜åŒ–ç­–ç•¥
        
        ç›®æ ‡ï¼šäººåƒè¯†åˆ«ä¼˜åŒ–ï¼Œä¿æŒé¢éƒ¨ç‰¹å¾æ¸…æ™°
        """
        import cv2
        
        height, width = frame.shape[:2]
        
        # æ‘„åƒå¤´å†…å®¹é€šå¸¸å·²ç»æ˜¯åˆé€‚çš„å°ºå¯¸ï¼ˆ500x500æˆ–ç±»ä¼¼ï¼‰
        # ä½†ç¡®ä¿ä¸ä¼šå¤ªå¤§å½±å“AIå¤„ç†é€Ÿåº¦
        max_size = 600
        if width > max_size or height > max_size:
            if width > height:
                new_width = max_size
                new_height = int(height * (max_size / width))
            else:
                new_height = max_size  
                new_width = int(width * (max_size / height))
                
            optimized = cv2.resize(frame, (new_width, new_height), interpolation=cv2.INTER_AREA)
            logger.info(f"ğŸ“· äººåƒå†…å®¹ç¼©æ”¾: {width}x{height} -> {new_width}x{new_height}")
        else:
            optimized = frame.copy()
            logger.info("ğŸ“· äººåƒå†…å®¹å°ºå¯¸åˆé€‚ï¼Œæ— éœ€ç¼©æ”¾")
            
        return optimized
    
    @staticmethod
    def save_base64_image(base64_data, output_path):
        """
        å°† Base64 ç¼–ç çš„å›¾ç‰‡ä¿å­˜ä¸ºæœ¬åœ°æ–‡ä»¶ã€‚

        :param base64_data: Base64 ç¼–ç çš„å›¾ç‰‡å­—ç¬¦ä¸²ï¼ˆä¸åŒ…æ‹¬å¤´éƒ¨ä¿¡æ¯ï¼‰
        :param output_path: ä¿å­˜å›¾ç‰‡çš„æœ¬åœ°è·¯å¾„ï¼ˆåŒ…å«æ–‡ä»¶åå’Œæ‰©å±•åï¼‰
        """
        try:
            # å»æ‰å¯èƒ½å­˜åœ¨çš„ Base64 å¤´éƒ¨ä¿¡æ¯ï¼ˆå¦‚ "data:image/png;base64,"ï¼‰
            if ',' in base64_data:
                _, base64_data = base64_data.split(',', 1)
            
            # è§£ç  Base64 æ•°æ®
            image_data = base64.b64decode(base64_data)

            # å°†è§£ç åçš„æ•°æ®å†™å…¥æ–‡ä»¶
            with open(output_path, 'wb') as f:
                f.write(image_data)
            
            logger.debug(f"å›¾ç‰‡å·²æˆåŠŸä¿å­˜è‡³ {output_path}")
        
        except Exception as e:
            logger.debug(f"ä¿å­˜å›¾ç‰‡æ—¶å‡ºé”™: {e}")
